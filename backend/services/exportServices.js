const jsPDF = require('jspdf').jsPDF;
const archiver = require('archiver');
const path = require('path');

class ExportService {
  
  // Generate Markdown content for PRD
  generatePRDMarkdown(project) {
    if (!project.prd?.content) {
      throw new Error('No PRD content available for export');
    }

    const prd = project.prd.content;
    const generatedDate = project.prd.generatedAt ? 
      new Date(project.prd.generatedAt).toLocaleDateString() : 'Unknown';

    let markdown = `# ${prd.title || project.title}

**Project:** ${project.title}  
**Generated:** ${generatedDate}  
**Version:** ${project.prd.version}

---

## Product Overview

${prd.overview || 'No overview provided'}

## Original Idea

${project.idea}

## Objectives

${prd.objectives ? prd.objectives.map(obj => `- ${obj}`).join('\n') : 'No objectives defined'}

## Target Audience

**Primary:** ${prd.targetAudience?.primary || 'Not defined'}  
**Secondary:** ${prd.targetAudience?.secondary || 'Not defined'}

## Features

${prd.features ? prd.features.map(feature => 
  `### ${feature.name} (${feature.priority} Priority)\n\n${feature.description}`
).join('\n\n') : 'No features defined'}

## Technical Requirements

${prd.technicalRequirements ? 
  prd.technicalRequirements.map(req => `- ${req}`).join('\n') : 
  'No technical requirements defined'}

## Timeline

**Estimated Duration:** ${prd.timeline?.estimatedDuration || 'Not specified'}

${prd.timeline?.phases ? 
  prd.timeline.phases.map(phase => 
    `### ${phase.phase}\n**Duration:** ${phase.duration}\n**Deliverables:**\n${phase.deliverables.map(d => `- ${d}`).join('\n')}`
  ).join('\n\n') : 
  'No phases defined'}

## Success Metrics

${prd.successMetrics ? 
  prd.successMetrics.map(metric => `- ${metric}`).join('\n') : 
  'No success metrics defined'}

## Risks & Challenges

${prd.risks ? 
  prd.risks.map(risk => `- ${risk}`).join('\n') : 
  'No risks identified'}

---

*Generated by Drishti.io - AI-Powered Product Planning*`;

    return markdown;
  }

  // Generate Markdown content for Implementation Plan
  generateImplementationPlanMarkdown(project) {
    if (!project.implementationPlan?.content) {
      throw new Error('No implementation plan content available for export');
    }

    const plan = project.implementationPlan.content;
    const generatedDate = project.implementationPlan.generatedAt ? 
      new Date(project.implementationPlan.generatedAt).toLocaleDateString() : 'Unknown';

    let markdown = `# ${project.title} - Implementation Plan

**Project:** ${project.title}  
**Generated:** ${generatedDate}  
**Version:** ${project.implementationPlan.version}

---

## Tech Stack

${plan.projectSetup?.techStack ? `
**Frontend:** ${plan.projectSetup.techStack.frontend?.join(', ') || 'Not specified'}  
**Backend:** ${plan.projectSetup.techStack.backend?.join(', ') || 'Not specified'}  
**Database:** ${plan.projectSetup.techStack.database || 'Not specified'}  
**Deployment:** ${plan.projectSetup.techStack.deployment || 'Not specified'}
` : 'Tech stack not defined'}

## Project Structure

${plan.projectSetup?.projectStructure ? 
  plan.projectSetup.projectStructure.map(folder => `- ${folder}`).join('\n') : 
  'Project structure not defined'}

## Development Phases

${plan.developmentPhases ? 
  plan.developmentPhases.map(phase => `
### ${phase.phase} (${phase.duration})

${phase.tasks.map(task => `
**${task.task}** (${task.estimatedHours})  
${task.description}  
${task.dependencies?.length ? `*Dependencies: ${task.dependencies.join(', ')}*` : ''}
`).join('\n')}
`).join('\n') : 'No development phases defined'}

## API Design

${plan.apiDesign ? 
  plan.apiDesign.map(api => `
### ${api.endpoint}
${api.description}  
**Parameters:** ${api.parameters?.join(', ') || 'None'}  
**Response:** ${api.response || 'Not specified'}
`).join('\n') : 'No API design specified'}

## Database Schema

${plan.databaseSchema ? 
  plan.databaseSchema.map(table => `
### ${table.table}
**Fields:** ${table.fields?.join(', ') || 'Not specified'}  
**Relationships:** ${table.relationships?.join(', ') || 'None'}
`).join('\n') : 'No database schema defined'}

## Testing Strategy

${plan.testing ? `
**Strategy:** ${plan.testing.strategy || 'Not defined'}  
**Types:** ${plan.testing.types?.join(', ') || 'Not specified'}  
**Tools:** ${plan.testing.tools?.join(', ') || 'Not specified'}
` : 'Testing strategy not defined'}

## Deployment

${plan.deployment ? `
**Strategy:** ${plan.deployment.strategy || 'Not defined'}  
**Environments:** ${plan.deployment.environments?.join(', ') || 'Not specified'}  

### CI/CD Pipeline
${plan.deployment.cicd?.map(step => `- ${step}`).join('\n') || 'Not defined'}
` : 'Deployment plan not defined'}

---

*Generated by Drishti.io - AI-Powered Product Planning*`;

    return markdown;
  }

  // Generate PDF from markdown-like content
  generatePDF(content, title) {
    const doc = new jsPDF();
    const pageHeight = doc.internal.pageSize.height;
    const margin = 20;
    let yPosition = margin;

    // Helper function to add text with word wrapping
    const addText = (text, fontSize = 12, isBold = false) => {
      if (yPosition > pageHeight - margin) {
        doc.addPage();
        yPosition = margin;
      }

      doc.setFontSize(fontSize);
      if (isBold) {
        doc.setFont(undefined, 'bold');
      } else {
        doc.setFont(undefined, 'normal');
      }

      const lines = doc.splitTextToSize(text, doc.internal.pageSize.width - 2 * margin);
      
      for (let line of lines) {
        if (yPosition > pageHeight - margin) {
          doc.addPage();
          yPosition = margin;
        }
        doc.text(line, margin, yPosition);
        yPosition += fontSize * 0.5;
      }
      yPosition += 5; // Extra space after text block
    };

    // Title
    addText(title, 20, true);
    yPosition += 10;

    // Process content (simplified markdown to PDF)
    const lines = content.split('\n');
    
    for (let line of lines) {
      line = line.trim();
      if (!line) {
        yPosition += 5;
        continue;
      }

      // Headers
      if (line.startsWith('# ')) {
        addText(line.substring(2), 18, true);
      } else if (line.startsWith('## ')) {
        addText(line.substring(3), 16, true);
      } else if (line.startsWith('### ')) {
        addText(line.substring(4), 14, true);
      } else if (line.startsWith('**') && line.endsWith('**')) {
        // Bold text
        addText(line.substring(2, line.length - 2), 12, true);
      } else if (line.startsWith('- ')) {
        // Bullet points
        addText('â€¢ ' + line.substring(2), 12);
      } else if (line.startsWith('*') && line.endsWith('*')) {
        // Italic (treat as normal for PDF)
        addText(line.substring(1, line.length - 1), 11);
      } else {
        // Normal text
        addText(line, 12);
      }
    }

    return doc;
  }

  // Generate complete project ZIP
  async generateProjectZIP(project, res) {
    try {
      const archive = archiver('zip', { zlib: { level: 9 } });
      
      // Set response headers
      res.setHeader('Content-Type', 'application/zip');
      res.setHeader('Content-Disposition', `attachment; filename="${project.title.replace(/[^a-zA-Z0-9]/g, '_')}_complete.zip"`);
      
      // Pipe archive to response
      archive.pipe(res);

      // Add project overview
      const projectOverview = `# ${project.title}

## Original Idea
${project.idea}

## Status
${project.status}

## Created
${project.createdAt ? new Date(project.createdAt).toLocaleDateString() : 'Unknown'}

## Last Updated
${project.updatedAt ? new Date(project.updatedAt).toLocaleDateString() : 'Unknown'}

---
Generated by Drishti.io
`;
      
      archive.append(projectOverview, { name: 'README.md' });

      // Add PRD if available
      if (project.prd?.content) {
        const prdMarkdown = this.generatePRDMarkdown(project);
        archive.append(prdMarkdown, { name: 'PRD.md' });
        
        // Add PRD PDF
        const prdPDF = this.generatePDF(prdMarkdown, `${project.title} - PRD`);
        archive.append(prdPDF.output(), { name: 'PRD.pdf' });
      }

      // Add Implementation Plan if available
      if (project.implementationPlan?.content) {
        const planMarkdown = this.generateImplementationPlanMarkdown(project);
        archive.append(planMarkdown, { name: 'Implementation_Plan.md' });
        
        // Add Implementation Plan PDF
        const planPDF = this.generatePDF(planMarkdown, `${project.title} - Implementation Plan`);
        archive.append(planPDF.output(), { name: 'Implementation_Plan.pdf' });
      }

      // Finalize the archive
      await archive.finalize();
      
    } catch (error) {
      console.error('ZIP generation error:', error);
      throw new Error('Failed to generate project ZIP');
    }
  }
}

module.exports = new ExportService();